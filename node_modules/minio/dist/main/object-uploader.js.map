{"version":3,"sources":["object-uploader.js"],"names":[],"mappings":"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","file":"object-uploader.js","sourcesContent":["/*\n * Minio Javascript Library for Amazon S3 Compatible Cloud Storage, (C) 2016 Minio, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Transform } from 'stream'\nimport { Hash } from 'crypto'\nimport * as querystring from 'querystring'\n\n// We extend Transform because Writable does not implement ._flush().\nexport default class ObjectUploader extends Transform {\n  constructor(client, bucketName, objectName, partSize, contentType, callback) {\n    super()\n\n    this.client = client\n    this.bucketName = bucketName\n    this.objectName = objectName\n    // The size of each multipart, chunked by BlockStream2.\n    this.partSize = partSize\n\n    // This contentType for the object.\n    this.contentType = contentType\n\n    // Call like: callback(error, etag).\n    this.callback = callback\n\n    // We need to keep track of what number chunk/part we're on. This increments\n    // each time _write() is called. Starts with 1, not 0.\n    this.partNumber = 1\n\n    // A list of the previously uploaded chunks, for resuming a file upload. This\n    // will be null if we aren't resuming an upload.\n    this.oldParts = null\n\n    // Keep track of the etags for aggregating the chunks together later. Each\n    // etag represents a single chunk of the file.\n    this.etags = []\n\n    // This is for the multipart upload request — if null, we're either not initiated\n    // yet or we're flushing in one packet.\n    this.id = null\n\n    // Handle errors.\n    this.on('error', err => {\n      callback(err)\n    })\n  }\n\n  _transform(chunk, encoding, callback) {\n    // Calculate the md5 sum.\n    let md5 = new Hash('md5')\n    md5.update(chunk)\n    let md5sum = md5.digest()\n\n    let method = 'PUT'\n    let headers = {\n      'Content-Length': chunk.length,\n      'Content-Type': this.contentType,\n      'Content-MD5': md5sum.toString('base64')\n    }\n\n    // We can flush the object in one packet if it fits in one chunk. This is true\n    // if the chunk size is smaller than the part size, signifying the end of the\n    // stream.\n    if (this.partNumber == 1 && chunk.length < this.partSize) {\n      // PUT the chunk in a single request — use an empty query.\n      let options = {\n        method, headers,\n        query: '',\n        bucketName: this.bucketName,\n        objectName: this.objectName\n      }\n\n      this.client.makeRequest(options, chunk, 200, '', (err, response) => {\n        if (err) return callback(err)\n\n        let etag = response.headers.etag\n        if (etag) {\n          etag = etag.replace(/^\\\"/, '').replace(/\\\"$/, '')\n        }\n\n        // Ignore the 'data' event so that the stream closes. (nodejs stream requirement)\n        response.on('data', () => {})\n\n        // Give the etag back, we're done!\n        process.nextTick(() => {\n          this.callback(null, etag)\n        })\n\n        // Because we're sure the stream has ended, allow it to flush and end.\n        callback()\n      })\n\n      return\n    }\n\n    // If we aren't flushing in one packet, we need to initiate the multipart upload,\n    // if it hasn't already been done. The write will be buffered until the upload has been\n    // initiated.\n    if (this.id === null) {\n      this.once('ready', () => {\n        this._transform(chunk, encoding, callback)\n      })\n\n      // Check for an incomplete previous upload.\n      this.client.findUploadId(this.bucketName, this.objectName, (err, id) => {\n        if (err) return this.emit('error', err)\n\n        // If no upload ID exists, initiate a new one.\n        if (!id) {\n          this.client.initiateNewMultipartUpload(this.bucketName, this.objectName, this.contentType, (err, id) => {\n            if (err) return callback(err)\n\n            this.id = id\n\n            // We are now ready to accept new chunks — this will flush the buffered chunk.\n            this.emit('ready')\n          })\n\n          return\n        }\n\n        this.id = id\n\n        // Retrieve the pre-uploaded parts, if we need to resume the upload.\n        this.client.listParts(this.bucketName, this.objectName, id, (err, etags) => {\n          if (err) return this.emit('error', err)\n\n          // It is possible for no parts to be already uploaded.\n          if (!etags) etags = []\n\n          // oldParts will become an object, allowing oldParts[partNumber].etag\n          this.oldParts = etags.reduce(function(prev, item) {\n            if (!prev[item.part]) {\n              prev[item.part] = item\n            }\n            return prev\n          }, {})\n\n          this.emit('ready')\n        })\n      })\n\n      return\n    }\n\n    // Continue uploading various parts if we have initiated multipart upload.\n    let partNumber = this.partNumber++\n\n    // Check to see if we've already uploaded this chunk. If the hash sums match,\n    // we can skip to the next chunk.\n    if (this.oldParts) {\n      let oldPart = this.oldParts[partNumber]\n\n      if (oldPart && md5sum.toString('hex') === oldPart.etag) {\n        // The md5 matches, the chunk has already been uploaded.\n        this.etags.push({part: partNumber, etag: oldPart.etag})\n\n        callback()\n        return\n      }\n    }\n\n    // Write the chunk with an uploader.\n    let query = querystring.stringify({\n      partNumber: partNumber,\n      uploadId: this.id\n    })\n\n    let options = {\n      method, query, headers,\n      bucketName: this.bucketName,\n      objectName: this.objectName\n    }\n\n    this.client.makeRequest(options, chunk, 200, '', (err, response) => {\n      if (err) return callback(err)\n\n      // In order to aggregate the parts together, we need to collect the etags.\n      let etag = response.headers.etag\n      if (etag)\n        etag = etag.replace(/^\\\"/, '').replace(/\\\"$/, '')\n\n      this.etags.push({part: partNumber, etag})\n\n      // We're ready for the next chunk.\n      callback()\n    })\n  }\n\n  _flush(callback) {\n    // If it has been uploaded in a single packet, we don't have to do anything.\n    if (this.id === null) {\n      return\n    }\n\n    // This is called when all of the chunks uploaded successfully, thus\n    // completing the multipart upload.\n    this.client.completeMultipartUpload(this.bucketName, this.objectName, this.id,\n                                        this.etags, (err, etag) => {\n      if (err) return callback(err)\n\n      // Call our callback on the next tick to allow the streams infrastructure\n      // to finish what its doing before we continue.\n      process.nextTick(() => {\n        this.callback(null, etag)\n      })\n\n      callback()\n    })\n  }\n\n}\n"]}